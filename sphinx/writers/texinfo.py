"""Custom docutils writer for Texinfo."""
from __future__ import annotations
import re
import textwrap
from collections.abc import Iterable, Iterator
from os import path
from typing import TYPE_CHECKING, Any, cast
from docutils import nodes, writers
from sphinx import __display_version__, addnodes
from sphinx.domains.index import IndexDomain
from sphinx.errors import ExtensionError
from sphinx.locale import _, __, admonitionlabels
from sphinx.util import logging
from sphinx.util.docutils import SphinxTranslator
from sphinx.util.i18n import format_date
from sphinx.writers.latex import collected_footnote
if TYPE_CHECKING:
    from docutils.nodes import Element, Node, Text
    from sphinx.builders.texinfo import TexinfoBuilder
    from sphinx.domains import IndexEntry
logger = logging.getLogger(__name__)
COPYING = '@quotation\n%(project)s %(release)s, %(date)s\n\n%(author)s\n\nCopyright @copyright{} %(copyright)s\n@end quotation\n'
TEMPLATE = '\\input texinfo   @c -*-texinfo-*-\n@c %%**start of header\n@setfilename %(filename)s\n@documentencoding UTF-8\n@ifinfo\n@*Generated by Sphinx ' + __display_version__ + '.@*\n@end ifinfo\n@settitle %(title)s\n@defindex ge\n@paragraphindent %(paragraphindent)s\n@exampleindent %(exampleindent)s\n@finalout\n%(direntry)s\n@c %%**end of header\n\n@copying\n%(copying)s\n@end copying\n\n@titlepage\n@title %(title)s\n@insertcopying\n@end titlepage\n@contents\n\n@c %%** start of user preamble\n%(preamble)s\n@c %%** end of user preamble\n\n@ifnottex\n@node Top\n@top %(title)s\n@insertcopying\n@end ifnottex\n\n@c %%**start of body\n%(body)s\n@c %%**end of body\n@bye\n'

def find_subsections(section: Element) -> list[nodes.section]:
    """Return a list of subsections for the given ``section``."""
    return [node for node in section.children if isinstance(node, nodes.section)]

def smart_capwords(s: str, sep: str | None=None) -> str:
    """Like string.capwords() but does not capitalize words that already
    contain a capital letter.
    """
    words = s.split(sep) if sep else s.split()
    capitalized = [word if any(c.isupper() for c in word) else word.capitalize() for word in words]
    return (sep or ' ').join(capitalized)

class TexinfoWriter(writers.Writer):
    """Texinfo writer for generating Texinfo documents."""
    supported = ('texinfo', 'texi')
    settings_spec: tuple[str, Any, tuple[tuple[str, list[str], dict[str, str]], ...]] = ('Texinfo Specific Options', None, (('Name of the Info file', ['--texinfo-filename'], {'default': ''}), ('Dir entry', ['--texinfo-dir-entry'], {'default': ''}), ('Description', ['--texinfo-dir-description'], {'default': ''}), ('Category', ['--texinfo-dir-category'], {'default': 'Miscellaneous'})))
    settings_defaults: dict[str, Any] = {}
    output: str
    visitor_attributes = ('output', 'fragment')

    def __init__(self, builder: TexinfoBuilder) -> None:
        super().__init__()
        self.builder = builder

class TexinfoTranslator(SphinxTranslator):
    ignore_missing_images = False
    builder: TexinfoBuilder
    default_elements = {'author': '', 'body': '', 'copying': '', 'date': '', 'direntry': '', 'exampleindent': 4, 'filename': '', 'paragraphindent': 0, 'preamble': '', 'project': '', 'release': '', 'title': ''}

    def __init__(self, document: nodes.document, builder: TexinfoBuilder) -> None:
        super().__init__(document, builder)
        self.init_settings()
        self.written_ids: set[str] = set()
        self.referenced_ids: set[str] = set()
        self.indices: list[tuple[str, str]] = []
        self.short_ids: dict[str, str] = {}
        self.node_names: dict[str, str] = {}
        self.node_menus: dict[str, list[str]] = {}
        self.rellinks: dict[str, list[str]] = {}
        self.collect_indices()
        self.collect_node_names()
        self.collect_node_menus()
        self.collect_rellinks()
        self.body: list[str] = []
        self.context: list[str] = []
        self.descs: list[addnodes.desc] = []
        self.previous_section: nodes.section | None = None
        self.section_level = 0
        self.seen_title = False
        self.next_section_ids: set[str] = set()
        self.escape_newlines = 0
        self.escape_hyphens = 0
        self.curfilestack: list[str] = []
        self.footnotestack: list[dict[str, list[collected_footnote | bool]]] = []
        self.in_footnote = 0
        self.in_samp = 0
        self.handled_abbrs: set[str] = set()
        self.colwidths: list[int] = []

    def collect_node_names(self) -> None:
        """Generates a unique id for each section.

        Assigns the attribute ``node_name`` to each section.
        """
        for section in self.document.traverse(nodes.section):
            if 'ids' in section:
                node_id = section['ids'][0]
                if node_id not in self.node_names:
                    self.node_names[node_id] = self.escape_id(section.get('names', [''])[0])
            section['node_name'] = self.node_names.get(node_id, '')

    def collect_node_menus(self) -> None:
        """Collect the menu entries for each "node" section."""
        for section in self.document.traverse(nodes.section):
            if 'node_name' in section:
                entries = []
                for subsection in find_subsections(section):
                    if 'node_name' in subsection:
                        entries.append((subsection['node_name'], 
                                        self.escape_menu(subsection.get('names', [''])[0])))
                self.node_menus[section['node_name']] = entries

    def collect_rellinks(self) -> None:
        """Collect the relative links (next, previous, up) for each "node"."""
        def process_section(section, parent=None):
            if 'node_name' not in section:
                return
            
            node_name = section['node_name']
            self.rellinks[node_name] = ['', '', '']
            
            if parent and 'node_name' in parent:
                self.rellinks[node_name][2] = parent['node_name']
            
            subsections = find_subsections(section)
            for i, subsection in enumerate(subsections):
                if 'node_name' in subsection:
                    if i > 0 and 'node_name' in subsections[i-1]:
                        self.rellinks[subsection['node_name']][1] = subsections[i-1]['node_name']
                    if i < len(subsections) - 1 and 'node_name' in subsections[i+1]:
                        self.rellinks[subsection['node_name']][0] = subsections[i+1]['node_name']
                    process_section(subsection, section)

        process_section(self.document)

    def escape(self, s: str) -> str:
        """Return a string with Texinfo command characters escaped."""
        return (s.replace('@', '@@')
                 .replace('{', '@{')
                 .replace('}', '@}')
                 .replace(',', '@,'))

    def escape_arg(self, s: str) -> str:
        """Return an escaped string suitable for use as an argument
        to a Texinfo command.
        """
        return s.replace(',', '@comma{}')
                .replace(':', '@colon{}')

    def escape_id(self, s: str) -> str:
        """Return an escaped string suitable for node names and anchors."""
        return (s.replace('@', '')
                 .replace(',', '')
                 .replace(':', '')
                 .replace(' ', '-')
                 .replace('_', '-')
                 .replace('(', '-')
                 .replace(')', '-'))

    def escape_menu(self, s: str) -> str:
        """Return an escaped string suitable for menu entries."""
        return self.escape_arg(s).replace(':', '')

    def ensure_eol(self) -> None:
        """Ensure the last line in body is terminated by new line."""
        if self.body and not self.body[-1].endswith('\n'):
            self.body[-1] += '\n'

    def get_short_id(self, id: str) -> str:
        """Return a shorter 'id' associated with ``id``."""
        if id not in self.short_ids:
            self.short_ids[id] = str(len(self.short_ids) + 1)
        return self.short_ids[id]
    headings = ('@unnumbered', '@chapter', '@section', '@subsection', '@subsubsection')
    rubrics = ('@heading', '@subheading', '@subsubheading')
    visit_doctest_block = visit_literal_block
    depart_doctest_block = depart_literal_block
    visit_attention = _visit_named_admonition
    depart_attention = depart_admonition
    visit_caution = _visit_named_admonition
    depart_caution = depart_admonition
    visit_danger = _visit_named_admonition
    depart_danger = depart_admonition
    visit_error = _visit_named_admonition
    depart_error = depart_admonition
    visit_hint = _visit_named_admonition
    depart_hint = depart_admonition
    visit_important = _visit_named_admonition
    depart_important = depart_admonition
    visit_note = _visit_named_admonition
    depart_note = depart_admonition
    visit_tip = _visit_named_admonition
    depart_tip = depart_admonition
    visit_warning = _visit_named_admonition
    depart_warning = depart_admonition
